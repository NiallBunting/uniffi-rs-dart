{#
# Python has a built-in `enum` module which is nice to use, but doesn't support
# variants with associated data. So, we switch here, and generate a stdlib `enum`
# when none of the variants have associated data, or a generic nested-class
# construct when they do.
#}
{% if e.is_flat() %}

// Enumtemplate
enum {{ type_name }} {
    _,
    {% for variant in e.variants() -%}
    {{ variant.name()|enum_variant_py }},
    {% endfor %}
}
{% else %}

// Generated by: EnumTemplate: 1
enum {{ type_name }} {

    // Each enum variant is a nested class of the enum itself.
    {% for variant in e.variants() -%}
    {{ variant.name()|enum_variant_py }},

    {% endfor %}
}

{% endif %}

// Generated By: EnumTemplate: 2
class {{ ffi_converter_name }} extends _UniffiConverterRustBuffer {
    static read(buf) {
        //variant = buf.read_i32()

        //{%- for variant in e.variants() %}
        //if variant == {{ loop.index }}:
        //    {%- if e.is_flat() %}
        //    return {{ type_name }}.{{variant.name()|enum_variant_py}}
        //    {%- else %}
        //    return {{ type_name }}.{{variant.name()|enum_variant_py}}(
        //        {%- for field in variant.fields() %}
        //        {{ field|read_fn }}(buf),
        //        {%- endfor %}
        //    )
        //    {%- endif %}
        //{%- endfor %}
        //raise InternalError("Raw enum value doesn't match any cases")
    }

    write(value, buf) {
        //{%- for variant in e.variants() %}
        //{%- if e.is_flat() %}
        //if value == {{ type_name }}.{{ variant.name()|enum_variant_py }}:
        //    buf.write_i32({{ loop.index }})
        //{%- else %}
        //if value.is_{{ variant.name()|var_name }}():
        //    buf.write_i32({{ loop.index }})
        //    {%- for field in variant.fields() %}
        //    {{ field|write_fn }}(value.{{ field.name()|var_name }}, buf)
        //    {%- endfor %}
        //{%- endif %}
        //{%- endfor %}
    }

}
